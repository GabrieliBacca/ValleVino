<template>
    <div :class="cx('root')" role="tablist">
        <div :class="cx('navContent')">
            <ul ref="list" :class="cx('nav')">
                <li
                    v-for="(step, index) of steps"
                    :key="getStepKey(step, index)"
                    :class="cx('step.header', { step, index })"
                    :style="getStepProp(step, 'headerStyle')"
                    :aria-current="isStepActive(index) ? 'step' : undefined"
                    @click="onItemClick($event, step, index)"
                    @keydown="onItemKeydown($event, step, index)"
                    v-bind="{ ...getStepPT(step, 'root', index), ...getStepPT(step, 'header', index) }"
                    data-pc-name="step"
                    :data-p-highlight="isStepActive(index)"
                    :data-p-disabled="getStepProp(step, 'disabled')"
                    :data-pc-index="index"
                    :data-p-active="isStepActive(index)"
                >
                    <slot name="header">
                        <span :class="cx('step.action')">
                            <span :class="cx('step.step')">{{ index + 1 }}</span>
                            <span :class="cx('step.title')">{{ getStepProp(step, 'header') }}</span>
                        </span>
                    </slot>
                </li>
            </ul>
        </div>
        <div :class="cx('stepContainer')">
            <template v-for="(step, index) of steps" :key="getStepKey(step, index)">
                <div
                    v-if="isStepActive(index)"
                    :id="getStepContentId(index)"
                    :class="cx('step.content', { step })"
                    :style="getStepProp(step, 'contentStyle')"
                    role="tabpanel"
                    :aria-labelledby="getStepHeaderActionId(index)"
                    v-bind="{ ...getStepPT(step, 'root', index), ...getStepPT(step, 'content', index) }"
                    data-pc-name="step"
                    :data-pc-index="index"
                    :data-p-active="isStepActive(index)"
                >
                    <component :is="step"></component>
                </div>
            </template>
        </div>
    </div>
</template>

<script>
import { UniqueComponentId } from 'primevue/utils';
import { mergeProps } from 'vue';
import BaseStepper from './BaseStepper.vue';

export default {
    name: 'Stepper',
    extends: BaseStepper,
    emits: ['update:activeStep', 'step-change'],
    data() {
        return {
            id: this.$attrs.id,
            d_activeStep: this.activeStep
        };
    },
    watch: {
        '$attrs.id': function (newValue) {
            this.id = newValue || UniqueComponentId();
        },
        activeStep(newValue) {
            this.d_activeStep = newValue;
        }
    },
    mounted() {
        this.id = this.id || UniqueComponentId();
    },
    methods: {
        isStep(child) {
            return child.type.name === 'Step';
        },
        isStepActive(index) {
            return this.d_activeStep === index;
        },
        getStepProp(step, name) {
            return step.props ? step.props[name] : undefined;
        },
        getStepKey(step, index) {
            return this.getStepProp(step, 'header') || index;
        },
        getStepHeaderActionId(index) {
            return `${this.id}_${index}_header_action`;
        },
        getStepContentId(index) {
            return `${this.id}_${index}_content`;
        },
        getStepPT(step, key, index) {
            const count = this.steps.length;
            const stepMetaData = {
                props: step.props,
                parent: {
                    instance: this,
                    props: this.$props,
                    state: this.$data
                },
                context: {
                    index,
                    count,
                    first: index === 0,
                    last: index === count - 1,
                    active: this.isStepActive(index)
                }
            };

            return mergeProps(this.ptm(`step.${key}`, { step: stepMetaData }), this.ptm(`step.${key}`, stepMetaData), this.ptmo(this.getStepProp(step, 'pt'), key, stepMetaData));
        },
        onItemClick(event, step, index) {
            if (this.getStepProp(step, 'disabled') || this.readonly) {
                event.preventDefault();

                return;
            }

            if (index !== this.d_activeStep) {
                this.d_activeStep = index;
                this.$emit('update:activeStep', this.d_activeStep);
            }

            this.$emit('step-change', {
                originalEvent: event,
                index: index
            });
        },
        onItemKeydown(event, tab) {
            switch (event.code) {
                case 'ArrowRight': {
                    this.navigateToNextItem(event.target);
                    event.preventDefault();
                    break;
                }

                case 'ArrowLeft': {
                    this.navigateToPrevItem(event.target);
                    event.preventDefault();
                    break;
                }

                case 'Home': {
                    this.navigateToFirstItem(event.target);
                    event.preventDefault();
                    break;
                }

                case 'End': {
                    this.navigateToLastItem(event.target);
                    event.preventDefault();
                    break;
                }

                case 'Tab':
                    //no op
                    break;

                case 'Enter':
                case 'NumpadEnter':

                case 'Space': {
                    this.onItemClick(event, step);
                    event.preventDefault();
                    break;
                }

                default:
                    break;
            }
        },
        navigateToNextItem(target) {
            const nextItem = this.findNextItem(target);

            nextItem && this.setFocusToMenuitem(target, nextItem);
        },
        navigateToPrevItem(target) {
            const prevItem = this.findPrevItem(target);

            prevItem && this.setFocusToMenuitem(target, prevItem);
        },
        navigateToFirstItem(target) {
            const firstItem = this.findFirstItem(target);

            firstItem && this.setFocusToMenuitem(target, firstItem);
        },
        navigateToLastItem(target) {
            const lastItem = this.findLastItem(target);

            lastItem && this.setFocusToMenuitem(target, lastItem);
        },
        findNextItem(item) {
            const nextItem = item.parentElement.nextElementSibling;

            return nextItem ? nextItem.children[0] : null;
        },
        findPrevItem(item) {
            const prevItem = item.parentElement.previousElementSibling;

            return prevItem ? prevItem.children[0] : null;
        },
        findFirstItem() {
            const firstSibling = DomHandler.findSingle(this.$refs.list, '[data-pc-section="header"]');

            return firstSibling ? firstSibling.children[0] : null;
        },
        findLastItem() {
            const siblings = DomHandler.find(this.$refs.list, '[data-pc-section="header"]');

            return siblings ? siblings[siblings.length - 1].children[0] : null;
        }
    },
    computed: {
        steps() {
            return this.$slots.default().reduce((steps, child) => {
                if (this.isStep(child)) {
                    steps.push(child);
                } else if (child.children && child.children instanceof Array) {
                    child.children.forEach((nestedChild) => {
                        if (this.isStep(nestedChild)) {
                            steps.push(nestedChild);
                        }
                    });
                }

                return steps;
            }, []);
        }
    }
};
</script>
